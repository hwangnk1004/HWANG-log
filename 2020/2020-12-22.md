## 2020-12-22

### 오늘 할 일
  - [x] 알고리즘 공부


## 결과

### 알고리즘 공부

* 동적 계획법과 분할 정복
	- 동적계획법 (DP)
		* 입력 크기가 작은 부분 문제들을 해결한 후, 해당 부분 문제의 해를 활용해서, 보다 큰 크기의 부분 문제를 해결, 최종적으로 전체 문제를 해결하는 알고리즘
		* 상향식 접근법으로, 가장 최하위 해답을 구한 후 , 이를 저장하고, 해당 결과값ㅇ르 이요해서 상위 문제를 풀어 가는 방식
		* Memorization 기법을 사용
			- Memorization이란 : 프로그램 실행 시 이전에 계산한 값을 저장하여, 다시 계산하지 않도록 하여 전체 실행 속도를 빠르게 하는 기술
			- 문제를 잘게 쪼갤 때, 부분 문제는 중복되어, 재활용 된다
				* ex) 피보나치

	- 분할 정복
		* 문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘
		* 하양식 접근법으로, 상위의 해답을 구하기 위해, 아래로 내려가면서 하위의 해답을 구하는 방식
			- 일반적으로 재귀함수로 구현
		* 문제를 잘게 쪼갤 때, 부분 문제는 서로 중복되지 않음
			- ex) 병합 정렬, 퀵 정렬 등

* 공통점과 차이점
	- 공통점
		* 문제를 잘게 쪼개서, 가장 작은 단위로 분할
	- 차이점
		* 동적 계획법
			- 부분 문제는 중복되어, 상위 문제 해결 시 재활용됨
			- Memorization 기법 (부분 문제의 해답을 저장해서 재활용하는 최적화 기법)

		* 분할 정복
			- 부분 문제는 서로 중복되지 않음
			- Memorization 기법 사용 안함


* 퀵 정렬 (quick sort)
	- 정렬 알고리즘의 꽃
	- 기준점(pivot)을 정해서, 기준점보다 작은 데이터를 왼쪽, 큰 데이터는 오른쪽으로 모으는 함수를 작성함
	- 각 왼쪽, 오른쪽은 재귀용법을 사용해서 다시 동일 함수를 호출하여 위 작업을 반복
	- 함수는 왼쪽(left)+기준점(pivot)+오른쪽(right)을 리턴

	- pivot 선택
		* 보통 인풋 배열의 가장 첫 번째 값을 활용

	- 알고리즘 분석
		* O(n log n)
			- 최악의 경우
				* 맨 처음 pivot이 가장 크거나, 가장 작으면
				* 모든 데이터를 비교하는 상황이 나옴
				* O(n제곱)


* 병합 정렬 (merge sort)
	- 재귀 용법을 활용한 정렬 알고리즘
		* 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
		* 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
		* 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.










## tags
-  \#java, \#soma, \#안드로이드

