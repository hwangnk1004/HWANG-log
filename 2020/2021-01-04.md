## 2021-01-04

### 오늘 할 일

  - [x] 면접 대비 공부



## 결과



#### 면접 대비 공부
* 스레드
	- 스레드는 실행 단위이다. main()이 시작되면 main() 메소드를 실행하는 하나의 스레드 A가 생긴다. 그리고 이 스레드는 main() 함수에서 호출하는 다른 객체의 메소드를 실행하고 여기서 또 다른 메소드가 호출되면 그 메소드 코드를 실행한다. 만일 중간에 새로운 스레드 B가 생기게 되면 이 스레드는 자신이 탄생한 코드에서 부터 독립적으로 실행을 진행한다.

* 컴퓨터 기술의 발전과 함께 멀티태스킹을 실현하기 위해 두 가지 방법이 사용되고 있다.

* 멀티 프로세싱
	- 하나의 응용프로그램을 여러 개의 프로세스(process)로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 기법이다. 각 프로세스는 고유한 메모리 영역을 보유하고 독립적으로 실행된다. 그러므로 하나의 응용프로그램에 속하는 프로세스들 조차 상호 통신의 오버헤드가 크고 프로세스의 문맥 교환에 따른 과도한 작업량과 시간 소모의 문제점이 있다.
* 멀티 스레딩
	- 멀티 프로세싱의 문제점을 개선하기 위해 제안된 방법이다.
		* 하나의 응용프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 기법이다. 모든 스레드가 응용프로그램 내의 자원과 메모리를 공유하므로 통신에 따른 오버헤드가 비교적 크지 않으며, 스레드 사이의 문맥 교환 시 작업량이 작고 시간이 짧은 장점을 지닌다. 

	- 멀티 스레딩의 필요성
		* 한글 프로그램을 예로 들어 설명해보자. 사용자가 일정 부분을 편집한 뒤 지금까지 편집된 내용을 프린트하고자 한다. 이때 만일 싱글 스레드로 한글 프로그램이 만들어져 있다면 어떻게 될까? 사용자가 프린트 메뉴를 누르면 프린트가 진행되고 프린터가 완전히 프린팅을 마칠 때까지 다른 작업을 전혀 할 수 없다. 사용자는 편집도 할 수 없고 다른 파일을 열 수 없으며, 현재 프린트 중인 내용을 저장할 수도 없다. 이 경우 한글프로그램은 오직 하나의 작업밖에 할 수 없다. 그러나 멀티스레드로 작성이 되어 있다면, 사용자가 프린트 메뉴를 선택하면 프린트 스레드를 생성하여 현재 편집 중인 버퍼의 내용을 프린터에 프린팅하도록 지시한다. 프린트 스레드가 프린팅을 진행하고 있는 동안 사용자로부터 다른 메뉴 입력을 받아 처리할 수 있다.

* 멀티스레드와 자바 가상 기계
	- 자바에는 프로세스 개념이 존재하지 않고 스레드 개념만 존재하며 자바 가상 기계(JVM)는 멀티스레딩만 지원한다. 자바 스레드란 JVM에 의해 스케줄되는 실행 단위 코드 블록이다.
	
	- 하나의 JVM은 하나의 자바 응용프로그램만 실행한다. JVM이 실행될 때 JVM이 자바 응용프로그램을 로딩하여 실행시킨다. 자바 응용프로그램이 종료되면 JVM도 함께 종료된다. 만일 한 컴퓨터에서 n개의 자바 응용프로그램이 실행되며 n개의 JVM이 실행이 되고 있는 것이다. 이들 각 자바 응용프로그램은 별개의 메모리 영역에서 독립적으로 실행된다. JVM은 멀티스레딩을 지원하며 따라서 자바 응용프로그램은 하나 이상의 스레드를 생성할 수 있다.

	- 두 개 이상의 응용프로그램이 같이 실행할 필요가 있고, 서로 정보를 주고받고자 하는 경우에는 소켓 통신 등의 여러 통신 방법을 이용한다.


* 자바 스레드와 JVM 
	- 스레드 스케줄링은 전적으로 JVM에 의해 이루어진다. 또한 스레드가 몇 개 존재하는지, 스레드로 실행되는 프로그램 코드의 메모리상 위치는 어디인지, 스레드의 상태는 무엇인지, 스레드의 우선순위는 얼마인지 등 많은 정보를 사실상 JVM의 메모리 영역 내에서 관리된다. 개발자의 임무는 자바 스레드로 작동할 스레드 코드를 작성하는 일뿐이다. 스레드를 관리하는 일은 모두 JVM의 일이다.

-> 스레드로 작동할 코드는 개발자가 준비하고, 스레드의 실행을 책임지는 것은 JVM이다.


* 스레드가 생성되면 스레드에 관련된 정보(Thread Control Block, TCB)가 생성되며 이들은 모두 JVM에 의해 관리된다.
	- TCB
		* 스레드 코드의 시작 주소, 스레드 상태, 스레드의 우선순위 값 등

	- TCB 정보르르 토대로 어떤 스레드를 실행시킬지를 결정하는 스레드 스케줄링은 JVM에 의해 이루어진다. 만일 JVM이 2번째 TCB를 선택하면 곧 그레드 2를 실행시키게 되며, 이 때 2번째 TCB 내에 기록된 스레드 시작 주소가 가리키는 스레드 코드 2를 실행한다. 스레드가 종료하면 해당 TCB는 사라진다.


* 스레드 만들기 : 자바 스레드를 만들기 위해 개발자는 다음 두 가지 작업을 하여야 한다.
	
	- 스레드 코드 작성
	
	- JVM에게 스레드를 생성하여 스레드 코드를 실행하도록 요청

	- 자바 스레드를 만드는 방법은 다음 2가지 있다.
		
		* Thread 클래스 이용

			- Thread 클래스는 스레드를 만들고 유지 관리하기 위해 많은 메소드를 제공한다.(대표적인 메소드만 소개하겠다)
				* Thread() : 스레드 객체 생성
				* Thread(Runnable target) : Runnable 객체인 target을 이용하여 스레드 객체 생성
				* Thread(String name) : 이름이 name인 스레드 객체 생성
				* Thread(Runnable target, String name) : Runnable 객체를 이용하며, 이름이 name인 스레드 객체 생성
				* void run() : <스레드 코드>로서 JVM에 의해 호출된다. 개발자는 반드시 오버라이딩하여 스레드 코드를 작성해야 한다. 이 메소드가 종료되면 스레드도 종료
				* void start() : JVM에게 스레드 실행을 시작하도록 요청
				* void interrupt() : 스레드 강제 종료


		* Runnable 인터페이스 이용

			- Runnable은 추상 메소드 run() 하나만 가지고 있다.


* 스레드 정보
	- 자바에서 스레드 코드는 Thread의 run() 메소드나 Runnable 인터페이스의 run() 메소드에 작성하여 객체 속에 캡슐화 하도록 되어 있다. start() 메소드가 호출되면 비로소 스레드는 생명을 가지고 실행되게 된다. JVM에 이ㅡ해 탄생된 스레드마다 흔히 Thread Control Block(TCB)이라고 불리는 스레드 관리 정보가 만들어진다. 


* 데몬 스레드와 일반 스레드
	
	- 자바에서 스레드는 두 가지 종류로 구분된다. 

		* 데몬 스레드 
			- JVM이 스스로 필요에 의해 사용하는 스레드이다. 가비지 컬렉션 스레드가 대표적인 데몬스레드이다.

		* 일반 스레드
			- 응용프로그램에서 생성한 스레드이다. main() 메소드도 대표적인 일반 스레드이다.

			- JVM은 응용프로그램에서 생성한 일반 스레드가 하나라도 살아 있는 한 실행을 계속한다. 그러나 응용프로그램의 일반 스레드가 모두 종료하면 데몬 스레드가 살아 있더라도 JVM은 스스로 종료하고 따라서 응용프로그램의 실행은 종료된다.

* 스레드 상태
	
	- 스레드는 하나의 생명체이다. 스레드는 태어나서 실행하고 종료하는 등 생명 주기(Life cycle)를 가진다. 그리고 생명 주기 동안 여러 상태의 변이를 거친다. 스레드의 상태는 총 6가지이며 JVM에 의해 관리된다.

		* NEW : 스레드가 생성되었지만 아직 실행할 준비가 되지 않은 상태이다. start() 메소드가 호출되면 RUNNABLE 상태가 된다.

		* RUNNABLE : 스레드가 현재 실행되고 있거나 실행 준비되어 스케줄링을 기다리는 상태이다.

		* WAITING : 스레드가 어떤 Object 타입의 객체 a에 대해 a.wait()을 호출하고 무한 대기하면서 다른 스레드가 a.notify(), a.notifyAll()을 불러주기를 기다리고 있는 상태이다. 스레드 동기화를 위해 사용된다.			

		* TIMED_WAITING : 스레드가 sleep(int n)을 호출하여 n밀리초 동안 잠을 자고 있는 상태이다.

		* BLOCK : 스레드가 I/O 작업을 요청하여 I/O 작업이 완료되기를 기다리는 상태이다. 응용프로그램이 I/O 작업을 실행하면 JVM이 자동으로 현재 스레드를 BLOCK 상태로 만든다.

		* TERMINATED : 스레드가 종료된 상태이다. 더 이상 다른 상태로 변이 할 수 없다.

* 자바 응용프로그램이 실행될 때 처음으로 생성되는 main 스레드 혹은 메인 스레드는 보통 값(5)의 우선순위로 태어나며, 자식 스레드는 부모 스레드와 같은 우선순위를 갖고 태어나기 때문에 main 스레드의 모든 자식 스레드는 보통 값 (5)의 우선순위를 가지고 탄생된다. 그러나 메소드를 이용하여 우선 순위를 변경할 수 있다.
	
	- ```java
		void setPriority(int new Priority)
		```



* main()은 자바의 main 스레드
	- main() 메소드는 누가 호출할까? main() 메소든느 JVM에 의해 생성된 main 스레드에 의해 호출된다. main 스레드는 JVM이 데몬 스레드가 아닌 일반 스레드로 등록한다. 그러므로 자바 응용프로그램의 main() 메소드가 실행되는 순간 2개의 스레드가 존재하는 셈이다. 하나는 main 스레드이고 다른 하나는 JVM이 생성한 가비지 컬렉터이다.



* 스레드 종료
	
	- 스레드가 종료되는 경우는 스레드 스스로 종료하는 것과 다른 스레으데 의해 강제 종료되는 경우 두 가지가 있다.

		* 스스로 종료
			- run() 메소드에서 실행 중간에 리턴하거나 run()를 완전히 실행하고 리턴하는 경우이다.

		* 강제 종료
			- 한 스레드가 다른 스레드를 강제로 종료시키고자 한다면 종료시키고자 하는 스레드 객체의 interrupt() 메소드를 호출하면 된다.


* 스레드 동기화

	- 멀티 스레드는 다수의 작업을 동시에 하게 하는 주요한 프로그래밍 도구이다. 그러나 다수의 스레드가 공유 자원 혹은 공유 데이터에 동시에 접근할 때 예상치 못하는 결과를 낳을 수 있다.

	- 멀티스레드 프로그램을 작성할 때 주의할 점은 다수의 스레드가 공유 데이터에 동시 접근하는 경우에 대한 처리이다. 이에 대한 해결책은 바로 스레드 동기화 이다.

	- 스레드 동기화
		* 공유 데이터에 접근하고자 하는 다수의 스레드가 서로 순서대로 충돌 없이 공유 데이터를 베타적으로 접근하기 위해 상호 협력하는 것을 말한다. 공유 데이터에 대한 접근은 베타적이고 독점적으로 이루어져야 하며, 이런 경우 공유 데이터를 다루는 프로그램 코드를 임계 영역이라고 부른다. 즉, 임계 영역에 대한 멀티스레드의 동기화가 필요하다.


* 자바의 스레드 동기화를 위한 synchronized 키워드
	- 자바에서 스레드 동기화를 위한 장치이다. synchronized 키워드는 임의의 코드 블록을 동기화가 설정된 임계 영역으로 지정한다. 한마디로 임계 영역 표시 키워드이다. synchronized 키워드를 이용하여 하나의 메소드 전체를 임게 영역으로 지정하는 방법과 임의의 코드 블록을 임계 영역으로 지정하는 두 가지 방법이 있다. 어떤 방법을 사용하던지 synchronized 블록은 진입할 때 락을 걸고 빠져나올때 락을 푸는 동작이 자동으로 이루어진다. 그러므로 먼저 synchronized블록에 진입하는 스레드가 락을 걸고 소유하며, 락을 소유하지 못한 다른 스레드는 synchronized 블록 앞에서 락을 소유할 때까지 대기한다.


* synchronized 키워드 사용하는 방법 외에 클래스의 wait(), notify(), notifyAll() 메소드를 이용하여 스레드를 동기화 하는 방법이 있다.
	- java.lang.Object 클래스는 스레드 사이에 동기화를 위한 3개의 메소드 wait(), notify(), notifyAll()를 제공한다. 그러므로 모든 자바 클래스가 이 3개의 메소드를 가지고 있는 셈이다.

		* wait() : 다른 스레드가 이 객체의 notify()를 불러줄 때까지 대기한다.

		* notify() : 이 객체에 대기 중인 스레드를 깨워 RUNNABLE상태로 만든다. 2개 이상의 스레드가 대기중이라도 오직 한개의 스레드만 개워 RUNNABLE상태로 한다.

		* notifyAll() : 이 객체에 대기 중인 모든 스레드를 깨우고 모두 RUNNABLE상태로 한다.

* 요약
	- 멀티스레딩은 하나의 응용프로그램이 여러 개의 스레드를 생성하여 여러 작업을 동시에 처리하는 프로그래밍 방식이다. 자바는 멀티 스레딩을 지원한다.
	- 자바 스레드는 JVM에 의해 관리되는 실행 단위 코드 블록이다.
	- 하나의 JVM은 하나의 자바 응용프로그램만을 실행하며 자바 응용프로그램이 시작될 때 JVM이 실행을 시작하고 자바 응용프로그램이 종료하면 JVM도 함께 종료한다.
	- 자바 스레드에 관한 정보는 스레드의 PC, 레지스터, 스레드 스택, 이름, ID, 상태 정보, 우선순위, 그룹 등이며 이들은 JVM에 의해 관리된다.
	- main() 메소드는 JVM에 의해 만들어진 main 스레드의 스레드 코드이다.
	- Thread 클래스를 상속받아 스레드 코드를 작성할 때는 run() 메소드를 오버라이딩하고 이곳에 스레드 코드를 작성한다. run() 메소드가 종료하면 스레드도 종료한다. 스레드를 동작시키기 위해서는 Thread의 start() 메소드를 호출한다.
	- 스레드는 NEW,RUNNABLE, WAITTING, TIMED_WAITING, BLOCK, TERMINATED의 6개 상태의 생명주기를 가진다.
	- 스레드를 JVM에 의해 철저히 우선순위 기반으로 스케줄링되며 동일한 우선순위에 대해서는 라운드 로빈 방식으로 스케줄링된다. 우선순위는 최댓값은 10이고 최솟값은 0이며 보통 값은 5이다. main() 스레드의 우선순위는 5이며 자식 스레드는 부모 스레드의 우선순위를 물려받아 태어난다.
	- 스레드가 타 스레드의 Thread 클래스 멤버 interrupt()를 호출하면 InterruptedException이 발생하며 타 스레드가 이 예외를 받아 단순 리턴하면 종료된다.
	- 다수의 스레드가 공유 데이터에 대한 동시적 접근, 즉 경쟁 상태가 발생하면 예기치 않은 잘못된 결과가 발생하므로 이를 해결하기 위해 스레드 동기화를 프로그램에 구현해야 한다.
	- synchronized 키워드는 메소드 전체나 코드 블록을 임계 영역 혹은 동기화 블록으로 지정하는데, 이 때 한 스레드가 이 코드 블록에 먼저 진입하면 다른 스레드는 대기하게 된다.
	- 스레드 동기화를 위한 다른 방법으로는 Object 클래스의 wait(), notify(), notifyAll()을 이용하는 방법이다. 한 스레드가 자신이 필요로 하는 자원을 다른 스레드가 사용중인 경우 약속된 객체의 wait() 메소드를 호출하여 자원을 사용중인 스레드가 깨워주기를 기다리는 상태에 진입한다. 자원을 다 사용한 스레드는 약속된 객체의 notify()나 notifyAll()을 호춯라여 대기 상태에 있는 스레드를 꺠워 작업을 진행하도록 한다.
	



	
* 안드로이드 컴파일 과정
	- 안드로이드 컴파일러가 소스코드를 DEX 파일로 변환하고, 리소스는 컴파일된 리소스로 만든다. 이를 바탕으로 APK Packager가 DEX파일과 컴파일된 리소스를 APK로 결합하여 APK를 만들어 낸다.

* 로우 메모리 처리에 대해
	- 시스템에 충분한 메모리를 확보할 수 없는 경우가 많다. 이 경우 시스템은 메모리가 부족하고 할당량을 줄요야 한다고 앱에 알린다. 이 방법으로 충분하지 않으면 메모리를 확보하려고 프로세스를 종료하기 시작한다. 이 작업을 로우 메모리 킬러가 하며, 종료할 프로세스를 판단하기 위해 lmk는 실행중인 프로세스의 우선순위를 정한다. 최고 점수를 얻은 프로세스가 먼저 종료된다. 이 같은 방법으로 메모리를 처리한다.

* 디자인 패턴 중 싱글턴 패턴에 대해
	- 특정 클래스에 대한 인스턴스를 단 한번만 Static 메모리 영역에 할당하고 해당 클래스에 대한 생성자를 여러 번 호출하더라도 최초에 생성된 객체를 반환하는 디자인 패턴이다. 특정 클래스에 유일 객체를 보장하는 디자인 형태라고 볼 수 있다. 일반적으로 싱글톤 패턴이 적용된 클래스에 대한 new 연산을 수행하더라도 이미 한번 할당된 메모리 영역의 인스턴스를 사용하기 때문에 무분별한 new 연산으로 인한 메모리 낭비를 방지 할 수 있다.


* 안드로이드 4대 컴포넌트
	- 액티비티, 서비스, 콘텐트 프로바이더, 브로드캐스트 리시버 이렇게 4가지를 말한다. 각각의 구성요소는 인텐트를 통해서 상호 통신한다. 

		* 액티비티
			- UI 화면을 담당하는 컴포넌트이다. Activity클래스를 상속해야 하며 액티비티가 기본적으로 가지고 있는 생명주기 메소드를 재정의하여 원하는 기능을 구현할 수 있다.

		* 서비스
			- 백그라운드에서 실행되는 프로세스를 의미한다. service클래스를 상속받아서 사용하고, 서비스는 화면이 존재하지 않고 새로 만든 후에는 매니페스트에 등록을 해줘야한다. 

		* 콘텐트 프로바이더 
			- 데이터를 관리하고 앱간 데이터를 제공하는데 사용된다.

		* 브로드 캐스트 리시버
			- 안드로이드 운영체제로 부터 발생하는 각종 이벤트와 정보를 받아서 핸들링하는 컴포넌트이다.
* 핸들러
	- 스레드를 관리하기 위한 객체이다. 메인스레드와 백그라운드 스레드 혹은 백그라운드 스레드 사이의 커뮤니 케이션을 하게 한다. 또 몇초나 몇 분 단위로 정기적으로 해야하는 백그라운드 작업을 수행하는데 선호된다.

* 오버로드와 오버라이딩 차이
	- 오버 로드 : 클래스 내에 같은 이름의 메서드를 정의할 수 있다. 그러나 메서드의 매개변수의 개수 또는 타입이 달라야 한다.
	- 오버라이딩 : 조상 클래스의 메서드를 재정의 해서 사용하는 것인데 이름, 매개변수, 리턴타입을 갖게하고 내용만 새로 작성해야한다.

* String과 StringBuffer,StringBuilder
	- String는 불변적이고 나머지는 가변적이다. 스트링은 문자열 연산이 적고 자주 참조하는 경우에 좋다
	- StringBuilder과StringBuffer은 둘다 가변적이지만 StringBuffer 동기화가 가능해서 멀티스레드 환경에 적합하고 String Builder은 동기화를 지원하지 않는다는 차이점이 있다.

* 인텐트와 인텐트 필터
	- 화면전환을 할 수 있고, 컴포넌트들 사이에 데이터를 주고받을 수 있는 용도로 사용된다.

	- 인텐트 필터는 암시적 인텐트일때 인텐트 정보중 필요한 인텐트만을 선택하여 받을 수 있게 해주는 것이다.


* 스레드와 어싱크 테스크의 차이
	- AsyncTask는 많은 데이터를 다운로드 할 필요가 없는 메인 스레드와 통신해야하는 작은 작업이다. 메인 스레드에서 실행하고 생성해야한다. 이 클래스를 사용하면 스레드 및 핸들러를 조작하지 않고도 UI 스레드에서 백그라운드 작업을 수행하고 결과를 보여줄 수 있다.

	- Thread는 일반적으로 중간 또는 많은 양의 데이터가 포함된 네트워크 작업(업로드 또는 다운로드), 

* Garbage Collection
	- 자바에는 GC라는 게 있다. 이는 Heap내의 더이상 사용되지 않을 객체의 메모리들을 알아서 해제해주는 역할을 한다. 객체들 간 참조하는 관계에는 최초 참조 시작점이 되는 Root Reference가 있다. GC는 이 Root Reference에 연결되어 있지 않은 인스턴스들을 메모리에서 해제한다. 이 '연결'의 종류에 따라 해제 규칙이 다르다. 이 GC의 행동을 개발자가 간섭할 수 있는 방법이 있는데 이게 바로 위크, 스트롱 레퍼런스 들이다.

		1) 스트롱 레퍼런스 : 일반적으로 '=' 기호를 사용하거나 메소드 파라키터로 객체를 직접 전달할 경우가 스트롱 레퍼런스 상태이다. 해당 객체는 메모리에서 해제하지 않는다.

		2) 위크 레퍼런스 : 위크 레퍼런스로 연결된 인스턴스들은 GC가 발생 전까지 참조를 유지하지만, GC 발생 순간 메모리에서 해제된다.

* 동기와 비동기 차이
	- 동기 (Synchronous)실행은 프로그램 실행 중 하나의 기능 또는 함수를 실행했을 때, 그것을 실행한 측에서 기능이나 함수의 모든 동작이 완료될때까지 대기하는 방식

	- 비동기(Asynchronous)실행은 기능 또는 함수의 동작이 끝나길 기다리지 않고 바로 다음 코드를 실행하는 방식


* 프로세스와 스레드 차이
	- 하나의 프로그램이 메모리에 올라가 실행되면 프로세스라고 부른다. 프로세스는 운영체제로부터 CPU와 메모리를 할당받게 된다. 스레드는 프로세스 내에서 동작하는 실행 흐름을 말한다. 하나의 프로세스에서는 하나의 스레드가 실행되고, 이 스레드를 메인 스레드라고 부르며 안드로이드 에서는 UI스레드 라고 부른다. 하나의 프로세스는 하나 이상의 프로세스를 가질 수 있고 스레드끼리는 프로세스 내의 자원을 공유할 수 있다.

	- 멀티 프로세싱을 하지않고 멀티 스레드를 하는 이유
		* 프로세스간 자원을 공유하지 않는다. 또 프로세스의 생성은 많은 리소스와 메모리가 사용되므로 비용이 크다. 따라서 여러 작업을 동시에 실행하기 위해서는 멀티 스레드를 사용하여 비동기적인 실행을 하는것이 더욱 효율적이다.

* 어플리케이션과 컨텍스트 
	- 어플리케이션은 앱 프로세스가 실행되면 가장 먼저 생성되는 객체로 하나의 어플리케이션 객체는 하나의 앱 프로세스와 대응된다. 앱이 백그라운드로 내려가도 앱 프로세스는 계속 살아있기 때문에 어플리케이션 객체도 살아있다고 할 수 있다.

	- 컨텍스트는 안드로이드 컴포넌트들이 동작하기 위해 필요한 정보를 담고 있는 객체이다. 각 각의 컴포넌트들은 자신만의 컨텍스트를 가지고 있다. 컨텍스트 내에는 어플리케이션 정보, 컨텍스트가 실행되는데 필요한 정보를 얻거나 시스템 서비스를 구동하는데 사용된다.

* 프래그먼트와 프래그먼트 생명주기 !!
	- 프래그먼트는 액티비티의 일부분에만 배치되는 화면 및 동작을 조작하기 위한 객체이다. 안드로이드에서 화면이 비교적 큰 태블릿의 등장으로 작은 단위의 화면의 생명주기 관리할 필요가 있어 추가 되었다. 프래그먼트 매니저를 통해서 여러개의 프래그먼트를 조작할 수 있다.



* 안드로이드 메모리 관리 방식
	- 안드로이드는 액티비티, 서비스, 리시버, 프로바이더를 실행하기 위해 앱이 실행되는 과정에서 프로세스를 생성한다. 실행중인 모든 앱은 컴포넌트가 모두 종료되어도 다음에 이 앱을 다시 실행할 가능성이 높기 때문에 프로세스를 바로 제거하지 않는다. 이는 앱을 실행하기 위해 프로세스를 생성하는 과정에서 딜레이가 발생하는데 이 딜레이를 줄이기 위함이다. 따라서 사용자에 의해 다시 앱이 실행되면 남아있던 프로세스가 존재하는 경우 바로 실행된다. 이 과정에서 쌓여있던 많은 프로세스로 인해 메모리가 부족해지는 경우 프로세스의 우선순위에 따라 프로세스를 종료하여 메모리를 확보한다.



* List, Set, Map
	- List : 순서가 있는 데이터 집합으로 데이터 중복 허용

	- Set : 순서의 의미가 없고, 데이터를 중복 허용하지 않음

	- Map : Key, Value형태로 데이터 관리

	






























































## tags
-  \#kotlin, \#android 

