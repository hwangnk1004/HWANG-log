## 2020-12-17

### 오늘 할 일
  - [x] 코틀린 안드로이드 레이아웃 스터디 


## 결과

#### 코틀린 안드로이드 레이아웃 스터디
* <레이아웃>
	- 뷰와 데이터를 연결하는것 -> 데이터 바인딩
	- Dp는 화면의 물리적 픽셀 밀도를 기반으로 하는 추상 단위이다.
		* ex) 1dp = 1 pixel (On 160 dpi screen)
		* ex) 1dp = 3 pixel (On 480 dpi screen)
		* Android 기기가 dp에서 픽셀 값으로의 변환을 자동으로 처리한다. 따라서 개발자는 레이아웃에서 측정 값을 지정하기 위해 dp 값을 사용하면 된다.
	- 레이아웃은 계층 구조로 구성된다. (그림 1)
		* 기본 작업이 다른 보기를 포함하는 보기를 ViewGroups라고 한다.
		* 일반적으로 레이아웃에는 최상위 ViewGroup 및 그 안에 모든 View가 들어있다.
		* LinearLayout은 뷰를 가로 또는 세로로 정렬 할 수 있는 ViewGroup 이다.
		 	- LinearLayout은 방향을 수평 또는 수직으로 설정하고 그런 다음 뷰를 추가한다.
		* 뷰 계층 구조가 깊을수록 Android 시스템이 레이아웃을 계산하는 데 더 많은 작업을 해야한다. (그림 2) 뷰 계층이 크면 결국 성능에 영향을 미칠 수 있다. 앱이 느리게 로드되고 사용자에게 제대로 응답하지 않을 수 있다. 이를 위해 데이터 바인딩이라는 기술과 패턴이 있다. (그림 8) 이를 통해 컴파일 타임에 레이아웃을 활동 또는 프래그먼트에 연결할 수 있다. (그림9) 컴파일러는 a라는 도우미 클래스를 생성한다.
		액티비티가 생성 될 때 바인딩 클래스,바인딩 클래스의 인스턴스도 마찬가지다.(그림10)
		그런 다음 엑세스 할 수 있다. (그림11) 

		* 데이터 바인딩 - 아이디어
			- 데이터 바인딩에 대한 가장 큰 아이디어는 컴파일 타임에 두 개의 멀리 있는 정보를 연결/ 매핑/ 바인딩하는 객체를 만들어 런타임에 찾을 필요가 없도록 하는 것이다. 
			- 이러한 바인딩을 표시하는 개체를 Binding 개체라고 한다. 컴파일러에 의해 생성되며 내부에서 작동하는 방식을 이해하는 것은 흥미롭지만 데이터 바인딩의 기본 사용에 대해 알 필요는 없다.

		* 데이터 바인딩 및 findViewByid
			- findViewByid는 호출 될 때마다 뷰 계층 구조를 탐색하므로 비용이 많이 드는 작업이다.
			- 데이터 바인딩이 활성화되면 컴파일러<layout>는 ID가 있는 모든 뷰에 대한 참조를 만들고 Binding 개체에 수집한다.
			- 코드에서 바인딩 개체의 인스턴스를 만든 다음 추가 오버 헤드 없이 바인딩 개체를 통해 뷰를 참조한다.

		


	- 패딩은 뷰 또는 요소의 경계 내부에 추가되는 간격이다. (그림3)
	- 여백은 경계 외부에 추가되는 간격이다. (그림 4)
	- 스크롤뷰는 자식으로 하나의 추가 된 뷰만 포함 할 수 있다. (그림5) 리니어 레이아웃 안에서 다른 보기를 추가 할 수 있다. (그림6) 하나의 그림만 스크롤할 경우 스크롤 뷰에 직접 넣을 수 있다. (그림7)

	- 제약 조건과 코드는 시각적 표현 없이는 매우 어렵다. 제약 레이아웃에는 몇 가지 분명한 이점이 있다. 화면과 해상도에 반응하도록 만들 수 있다. 일반적으로 계층구조가 더 평평해진다 뷰 레이아웃에 최적화 되어 있다. 화면의 아무 곳에나 뷰를 배치할 수 있으며 편집기는 제약조건을 추가하는데 도움이 된다. 그러나 제약 레이아웃으로 거의 모든 레이아웃을 구축 할 수 있다고 해도 적은 수를 준비해야 할 때 가장 잘 작동한다. 




## tags
-  \#java, \#soma, \#안드로이드

